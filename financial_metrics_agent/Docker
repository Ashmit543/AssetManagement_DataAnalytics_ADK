# STEP 1: Choose a base image
# We start with a base image that already has Python 3.9 installed.
# "slim-buster" is a lightweight Debian-based image.
FROM python:3.9-slim-buster

# STEP 2: Set environment variables
# This ensures that Python output (like print statements) immediately
# appears in your logs, which is helpful for debugging on Cloud Run.
ENV PYTHONUNBUFFERED True

# STEP 3: Create a working directory inside the container
# All subsequent commands will run from this directory inside the container.
# If /app doesn't exist, Docker will create it.
WORKDIR /app

# STEP 4: Copy dependency file
# Copy your requirements.txt from your local machine (where you run docker build)
# into the /app directory inside the container.
COPY requirements.txt .

# STEP 5: Install Python dependencies
# Run pip to install all libraries listed in requirements.txt.
# This happens once when the image is built.
RUN pip install -r requirements.txt

# STEP 6: Copy your application code
# Copy your main.py (and any other Python code files) into the /app directory.
COPY main.py .

# STEP 7: Define the command to run when the container starts
# This tells Docker what command to execute to start your web service.
# Cloud Run automatically sets an environment variable $PORT to tell your app
# which port to listen on.
# `gunicorn` is a production-ready HTTP server for Python web apps.
# `--bind :$PORT`: Listen on all network interfaces on the port specified by Cloud Run.
# `--workers 1`: Run with 1 worker process (adjust for higher concurrency if needed).
# `--threads 8`: Use 8 threads per worker for concurrent handling of requests.
# `--timeout 0`: No timeout for requests (useful for long-running tasks, but be mindful).
# `main:app`: Tells gunicorn to find the 'app' object in 'main.py'.
CMD exec gunicorn --bind :$PORT --workers 1 --threads 8 --timeout 0 main:app.venv\Scripts\activate
